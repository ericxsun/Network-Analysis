function adjL = model_smallworld_kleinberg1D(L, q, alpha, adjL, pdist)
%MODEL_SMALLWORLD_KLEIBERG1D Generate a directed 1D lattice with the Periodic 
%Boundary Conditions according to the Jon Kleinberg model.
%   adjL = MODEL_SMALLWORLD_KLEINBERG1D(L, q, alpha, adjL, pdist) returns the
%   adjacency list of a directd 1D lattice generated by the method  described in
%   section Algorithm.
%
%   Algorithm:
%   Step 1. If 'adjL' is empty, then generate a regular 1D lattice. In which, 
%           the neighborhood of each node contains all the nodes within 'pdist' 
%           lattice steps. These contacts are called 'local contacts'.
%   Step 2. Construct q directed edges from each node(u) to other nodes (long-
%           range contacts) using independent random trials: the ith directed 
%           edge from u has endpoint v with probability proportional to:
%                   [d(u,v)]^-alpha
%           (To obtain a probability distribution, we divide this quantity by 
%           the appropriate normalizing constant sum_v [d(u,v)]^-alpha.)
%
%   Note:
%   1. Default, set pdist == 1.
%   2. The node in the adjacency list starts at zero, i.e., adjL{i} represents 
%      the neighbors of node i-1, i ranges from 1 to N, where N is the number 
%      of nodes.
%
%   Example:
%
%   Ref:
%   Kleinberg J M. Navigation in a small world[J]. Nature, 2000, 406(6798): 
%   845-845.
%
%   See also: MODEL_SMALLWORLD_KLEINBERG2D
%

%   Author: Eric x. sun
%   Email:  followyourheart1211@gmail.com
%   $Date:  2013/10/10 09:00$
%

%-------------------------------------------------------------------------------

assert(0 < L, 'L > 0 is required.');

N = L;

%Step 1. local contacts
if nargin <= 3
    adjL = cell(N, 1);
    adjL(:) = {[]};
end

if isempty(find(not(cellfun(@isempty, adjL)), 1))
    if nargin <= 4
        pdist = 1;
    end
    
    msg = sprintf('0 < pdist <= %d is required.', floor(L/2));
    assert(0 < pdist && pdist <= floor(L/2), msg);
    
    adjL = model_Regular1Dlattice_pbc(L, pdist);
end

%Step 2. long range contacts

%compute the weights
u0 = 0;

vu0 = [];   %all order neighbors
for pd = 1 : floor(L/2)
    neigh = find_d_neighbors(L, u0, pd);
    vu0 = [vu0; neigh];
end

gtu0 = vu0 > floor(L/2) + u0;
vu0(gtu0 > 0) = vu0(gtu0 > 0) - L;

dist_u0 = abs(bsxfun(@minus, vu0, 0));
weight  = bsxfun(@power, dist_u0, -alpha);

%add long contacts
percent10 = 1;
fprintf('Adding: 0%%');
for u = 0 : N-1
    if u == round(percent10 * (N-1) / 10)
        fprintf('==>%2d%%', percent10 * 10);
        percent10 = percent10 + 1;
    end
    
    %transfer u0 to u
    dist = u - u0;
    
    vu = vu0 + dist;
    vu(vu >= L) = vu(vu >= L) - L;
    vu(vu <  0) = vu(vu <  0) + L;
    
    while 1
        chose = randsample(vu, q, true, weight);
        chose = setdiff(chose(:), adjL{u+1}(:));
        
        if length(chose) == q
            break;
        end
    end
    
    adjL{u+1} = [adjL{u+1}(:); chose(:)];
end
fprintf('\n');

%--------------------------------------------------------------------------
end

function v = find_d_neighbors(L, u, pdist)
%find the neighbors of u with lattice distance pdist
%
% ..., L-2, L-1, L, 0, 1, 2, 3, ..., L-1
%

msg = sprintf('0 < pdist <= %d is required.', floor(L/2));
assert(0 < pdist && pdist <= floor(L/2), msg);

dist = [-pdist; pdist];
v    = u + dist;
v(v >= L) = v(v >= L) - L;
v(v <  0) = v(v <  0) + L;

v = unique(v(:));

end