function adjL = model_smallworld_kleinberg2D(L, q, alpha, adjL, pdist)
%MODEL_SMALLWORLD_KLEIBERG2D Generate a directed 2D lattice with the Periodic 
%Boundary Conditions according to the Jon Kleinberg model.
%   adjL = MODEL_SMALLWORLD_KLEINBERG2D(L, q, alpha, adjL, pdist) returns the
%   adjacency list of a directd 2D lattice generated by the method  described in
%   section Algorithm.
%
%   Algorithm:
%   Step 1. If 'adjL' is empty, then generate a regular 2D lattice. In which, 
%           the neighborhood of each node contains all the nodes within 'pdist' 
%           lattice steps. These contacts are called 'local contacts'.
%   Step 2. Construct q directed edges from each node(u) to other nodes (long-
%           range contacts) using independent random trials: the ith directed 
%           edge from u has endpoint v with probability proportional to:
%                   [d(u,v)]^-alpha
%           (To obtain a probability distribution, we divide this quantity by 
%           the appropriate normalizing constant sum_v [d(u,v)]^-alpha.)
%
%   Note:
%   1. Default, set pdist == 1.
%   2. The node in the adjacency list starts at zero, i.e., adjL{i} represents 
%      the neighbors of node i-1, i ranges from 1 to N, where N is the number 
%      of nodes.
%
%   Example:
%
%   Ref:
%   Kleinberg J M. Navigation in a small world[J]. Nature, 2000, 406(6798): 
%   845-845.
%
%   See also: MODEL_SMALLWORLD_KLEINBERG1D
%

%   Author: Eric x. sun
%   Email:  followyourheart1211@gmail.com
%   $Date:  2013/10/10 09:00$
%

%-------------------------------------------------------------------------------

% assert(0 < L && mod(L, 2) == 1, '0 < L and odd value is required.');

N = L*L;

%Step 1. local contacts
if nargin <= 3
    adjL = cell(N, 1);
    adjL(:) = {[]};
end

if isempty(find(not(cellfun(@isempty, adjL)), 1))
    if nargin <= 4
        pdist = 1;
    end
    
    msg = sprintf('0 < pdist <= %d is required.', L);
    assert(0 < pdist && pdist <= L, msg);
    
    adjL = model_Regular2Dlattice_pbc(L, pdist);
end

%Step 2. long range contacts

%compute the weights
%u = 0
u0x = mod(0, L)  + 1;
u0y = floor(0/L) + 1;

vu0 = [];   %all order neighbors
for pd = 1 : L
    neigh = find_d_neighbors(L, [u0x, u0y], pd);
    vu0 = [vu0; neigh];
end
vxu0 = mod(vu0, L)   + 1;
vyu0 = floor(vu0./L) + 1;

gtx = vxu0 > floor(L/2) + u0x;
gty = vyu0 > floor(L/2) + u0y;
vxyu0 = [vxu0, vyu0];
vxyu0(gtx, 1) = vxu0(gtx) - L;
vxyu0(gty, 2) = vyu0(gty) - L;

dist_u0 = sum(abs(bsxfun(@minus, vxyu0, [1, 1])), 2);
weight  = bsxfun(@power, dist_u0, -alpha);

%add long contacts
percent10 = 1;
fprintf('Adding: 0%%');
for u = 0 : N-1
    if u == round(percent10 * (N-1) / 10)
        fprintf('==>%2d%%', percent10 * 10);
        percent10 = percent10 + 1;
    end
    
    ux = mod(u, L)  + 1;
    uy = floor(u/L) + 1;
    
    dx = ux - u0x;
    dy = uy - u0y;
        
	vxyu = [vxu0+dx, vyu0+dy];
	vxyu(vxyu(:, 1) > L, 1) = vxyu(vxyu(:, 1) > L, 1) - L;
	vxyu(vxyu(:, 1) < 1, 1) = vxyu(vxyu(:, 1) < 1, 1) + L;
	vxyu(vxyu(:, 2) > L, 2) = vxyu(vxyu(:, 2) > L, 2) - L;
	vxyu(vxyu(:, 2) < 1, 2) = vxyu(vxyu(:, 2) < 1, 2) + L;
    vu = vxyu(:, 1) - 1 + (vxyu(:, 2)-1).*L;
    
    while 1
        chose = randsample(vu, q, true, weight);
        chose = setdiff(chose(:), adjL{u+1}(:));
        
        if length(chose) == q
            break;
        end
    end
    
    adjL{u+1} = [adjL{u+1}(:); chose(:)];
end
fprintf('\n');

%--------------------------------------------------------------------------
end

function v = find_d_neighbors(L, u, pdist)
%find the neighbors of u with lattice distance pdist
%           x x+1
%           ||
%     2     ||
%           ||   1
% y+1 ------||
% ----------+-------- y
%          ||-------- y-1
%          ||
%     3    ||    4
%          ||
%        x-1 x
%

uv= [];

pdist_max = floor(L/2);

ux = u(1);
uy = u(2);

%quadrant 1
bx = ux + pdist_max;            %boundary
by = uy - pdist_max;

dx = (1       :  1 : pdist)';   %dx + dy = pdist
dy = (pdist-1 : -1 : 0)';

x = ux + dx;
y = uy - dy;

xy = [x, y];
xy(xy(:, 1) > bx, :) = [];
xy(xy(:, 2) < by, :) = [];

uv = [uv; xy];

%quadrant 2
bx = ux - pdist_max;            %boundary
by = uy - pdist_max;

dx = (0     :  1 : pdist-1)';   %dx + dy = pdist
dy = (pdist : -1 : 1)';

x = ux - dx;
y = uy - dy;

xy = [x, y];
xy(xy(:, 1) < bx, :) = [];
xy(xy(:, 2) < by, :) = [];

uv = [uv; xy];

%quadrant 3
bx = ux - pdist_max;
by = uy + pdist_max;

dx = (1       :  1 : pdist)';
dy = (pdist-1 : -1 : 0)';

x = ux - dx;
y = uy + dy;

xy = [x, y];
xy(xy(:, 1) < bx, :) = [];
xy(xy(:, 2) > by, :) = [];

uv = [uv; xy];

%quadrant 4
bx = ux + pdist_max;
by = uy + pdist_max;

dx = (0     :  1 : pdist-1)';
dy = (pdist : -1 : 1)';

x = ux + dx;
y = uy + dy;

xy = [x, y];
xy(xy(:, 1) > bx, :) = [];
xy(xy(:, 2) > by, :) = [];

uv = [uv; xy];

%final
uv(uv(:, 1) > L, 1) = uv(uv(:, 1) > L, 1) - L;
uv(uv(:, 1) < 1, 1) = uv(uv(:, 1) < 1, 1) + L;
uv(uv(:, 2) > L, 2) = uv(uv(:, 2) > L, 2) - L;
uv(uv(:, 2) < 1, 2) = uv(uv(:, 2) < 1, 2) + L;

v = (uv(:,1)-1) + (uv(:,2)-1).*L;
v = unique(v);

end